<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Arix Signature Tree</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
      body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background-color: #000500; }
      #root { width: 100%; height: 100%; }
      /* Loader */
      #loader {
        position: absolute;
        top: 0; left: 0; width: 100%; height: 100%;
        background: #000500;
        display: flex;
        justify-content: center;
        align-items: center;
        color: #043927;
        font-family: serif;
        z-index: 9999;
        transition: opacity 1s ease-out;
        pointer-events: none;
      }
    </style>
    <!-- Import Map for ES Modules -->
    <script type="importmap">
{
  "imports": {
    "react": "https://esm.sh/react@19.0.0-rc.0?dev",
    "react-dom/client": "https://esm.sh/react-dom@19.0.0-rc.0/client?dev",
    "three": "https://esm.sh/three@0.160.0",
    "@react-three/fiber": "https://esm.sh/@react-three/fiber@8.15.16?external=react,react-dom,three",
    "@react-three/drei": "https://esm.sh/@react-three/drei@9.99.0?external=react,react-dom,three,@react-three/fiber",
    "@react-three/postprocessing": "https://esm.sh/@react-three/postprocessing@2.16.0?external=react,react-dom,three,@react-three/fiber",
    "react-dom/": "https://esm.sh/react-dom@^19.2.4/",
    "react/": "https://esm.sh/react@^19.2.4/"
  }
}
</script>
    <!-- Babel for in-browser transpilation of JSX/TS -->
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>
  <link rel="stylesheet" href="/index.css">
</head>
  <body>
    <div id="root"></div>
    <div id="loader"><h1 style="color: #FFD700; font-size: 1.5rem; letter-spacing: 0.2em;">LOADING ARIX...</h1></div>

    <script type="text/babel" data-type="module" data-presets="react,typescript">
      import React, { useState, useRef, useMemo, useLayoutEffect } from 'react';
      import ReactDOM from 'react-dom/client';
      import * as THREE from 'three';
      import { Canvas, useFrame } from '@react-three/fiber';
      import { OrbitControls, PerspectiveCamera, Environment, Float, Extrude } from '@react-three/drei';
      import { EffectComposer, Bloom, Vignette } from '@react-three/postprocessing';

      // ----------------------------------------------------------------------
      // CONSTANTS
      // ----------------------------------------------------------------------
      
      // Counts
      const FOLIAGE_COUNT = 12000;
      const ORNAMENT_COUNT = 400; // Total ornaments

      // Geometry
      const TREE_HEIGHT = 16;
      const TREE_RADIUS = 6.5;

      // Colors
      const COLOR_EMERALD = new THREE.Color('#043927'); // Deep Luxury Green
      const COLOR_EMERALD_LIGHT = new THREE.Color('#0d5c40'); // Slightly lighter green for depth
      const COLOR_GOLD = new THREE.Color('#FFD700');    // High Polish Gold
      const COLOR_WARM_WHITE = new THREE.Color('#FFF5E1'); // Warm Light

      // Animation
      const TRANSITION_SPEED = 2.0;

      // ----------------------------------------------------------------------
      // TYPES (Simulated for runtime)
      // ----------------------------------------------------------------------
      
      const TreeMorphState = {
        SCATTERED: 'SCATTERED',
        TREE_SHAPE: 'TREE_SHAPE',
      };

      // ----------------------------------------------------------------------
      // COMPONENT: Foliage
      // ----------------------------------------------------------------------

      // Custom Shader Material for the Foliage
      const FoliageShaderMaterial = {
        uniforms: {
          uTime: { value: 0 },
          uMorph: { value: 0 }, // 0 = Scattered, 1 = Tree
          uColorBase: { value: COLOR_EMERALD },
          uColorTip: { value: COLOR_EMERALD_LIGHT },
        },
        vertexShader: `
          uniform float uTime;
          uniform float uMorph;
          uniform vec3 uColorBase;
          uniform vec3 uColorTip;
          
          attribute vec3 aTreePos;
          attribute float aRandom;
          attribute float aSize;
          varying vec3 vColor;
          varying float vAlpha;

          // Simplex noise function
          vec3 mod289(vec3 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
          vec4 mod289(vec4 x) { return x - floor(x * (1.0 / 289.0)) * 289.0; }
          vec4 permute(vec4 x) { return mod289(((x*34.0)+1.0)*x); }
          vec4 taylorInvSqrt(vec4 r) { return 1.79284291400159 - 0.85373472095314 * r; }
          float snoise(vec3 v) {
            const vec2  C = vec2(1.0/6.0, 1.0/3.0) ;
            const vec4  D = vec4(0.0, 0.5, 1.0, 2.0);
            vec3 i  = floor(v + dot(v, C.yyy) );
            vec3 x0 = v - i + dot(i, C.xxx) ;
            vec3 g = step(x0.yzx, x0.xyz);
            vec3 l = 1.0 - g;
            vec3 i1 = min( g.xyz, l.zxy );
            vec3 i2 = max( g.xyz, l.zxy );
            vec3 x1 = x0 - i1 + C.xxx;
            vec3 x2 = x0 - i2 + C.yyy; // 2.0*C.x = 1/3 = C.y
            vec3 x3 = x0 - D.yyy;      // -1.0+3.0*C.x = -0.5 = -D.y
            i = mod289(i);
            vec4 p = permute( permute( permute(
                      i.z + vec4(0.0, i1.z, i2.z, 1.0 ))
                    + i.y + vec4(0.0, i1.y, i2.y, 1.0 ))
                    + i.x + vec4(0.0, i1.x, i2.x, 1.0 ));
            float n_ = 0.142857142857;
            vec3  ns = n_ * D.wyz - D.xzx;
            vec4 j = p - 49.0 * floor(p * ns.z * ns.z);
            vec4 x_ = floor(j * ns.z);
            vec4 y_ = floor(j - 7.0 * x_ );
            vec4 x = x_ *ns.x + ns.yyyy;
            vec4 y = y_ *ns.x + ns.yyyy;
            vec4 h = 1.0 - abs(x) - abs(y);
            vec4 b0 = vec4( x.xy, y.xy );
            vec4 b1 = vec4( x.zw, y.zw );
            vec4 s0 = floor(b0)*2.0 + 1.0;
            vec4 s1 = floor(b1)*2.0 + 1.0;
            vec4 sh = -step(h, vec4(0.0));
            vec4 a0 = b0.xzyw + s0.xzyw*sh.xxyy ;
            vec4 a1 = b1.xzyw + s1.xzyw*sh.zzww ;
            vec3 p0 = vec3(a0.xy,h.x);
            vec3 p1 = vec3(a0.zw,h.y);
            vec3 p2 = vec3(a1.xy,h.z);
            vec3 p3 = vec3(a1.zw,h.w);
            vec4 norm = taylorInvSqrt(vec4(dot(p0,p0), dot(p1,p1), dot(p2, p2), dot(p3,p3)));
            p0 *= norm.x;
            p1 *= norm.y;
            p2 *= norm.z;
            p3 *= norm.w;
            vec4 m = max(0.6 - vec4(dot(x0,x0), dot(x1,x1), dot(x2,x2), dot(x3,x3)), 0.0);
            m = m * m;
            return 42.0 * dot( m*m, vec4( dot(p0,x0), dot(p1,x1),
                                          dot(p2,x2), dot(p3,x3) ) );
          }

          void main() {
            // 1. Interpolate Position
            vec3 pos = mix(position, aTreePos, smoothstep(0.0, 1.0, uMorph));

            // 2. Add organic movement (Breathing)
            // Only apply full breathing when in tree shape to simulate wind/life
            float noiseVal = snoise(vec3(pos.x * 0.5, pos.y * 0.5 + uTime * 0.5, pos.z * 0.5));
            vec3 breathOffset = vec3(
              sin(uTime * 2.0 + aRandom * 10.0) * 0.1,
              cos(uTime * 1.5 + aRandom * 10.0) * 0.1,
              0.0
            );
            
            // Apply noise mostly in tree state
            pos += breathOffset * uMorph; 
            
            // 3. Size Calculation
            // Scale down slightly when scattered, pop up when tree
            float currentSize = aSize * (0.5 + 0.5 * uMorph);
            
            vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
            gl_PointSize = currentSize * (300.0 / -mvPosition.z);
            gl_Position = projectionMatrix * mvPosition;

            // 4. Color Variation
            // Mix base emerald with a lighter tip color based on noise
            vColor = mix(uColorBase, uColorTip, aRandom);
            vAlpha = 0.8 + 0.2 * sin(uTime + aRandom * 100.0);
          }
        `,
        fragmentShader: `
          varying vec3 vColor;
          varying float vAlpha;

          void main() {
            // Circular particle
            vec2 coord = gl_PointCoord - vec2(0.5);
            float dist = length(coord);
            if (dist > 0.5) discard;

            // Soft edge glow
            float glow = 1.0 - smoothstep(0.3, 0.5, dist);
            
            gl_FragColor = vec4(vColor * (1.0 + glow * 0.5), vAlpha);
            
            // Tone mapping fix hack for raw shader usage in r3f if needed, 
            // but usually handled by canvas. 
            #include <tonemapping_fragment>
            #include <colorspace_fragment>
          }
        `
      };

      const Foliage = ({ state }) => {
        const shaderRef = useRef(null);

        // Generate Geometry Data
        const { positions, treePositions, randoms, sizes } = useMemo(() => {
          const pos = new Float32Array(FOLIAGE_COUNT * 3);
          const treePos = new Float32Array(FOLIAGE_COUNT * 3);
          const rands = new Float32Array(FOLIAGE_COUNT);
          const s = new Float32Array(FOLIAGE_COUNT);

          for (let i = 0; i < FOLIAGE_COUNT; i++) {
            const i3 = i * 3;

            // SCATTER POS: Large Sphere
            const rScatter = 20 + Math.random() * 20;
            const thetaS = Math.random() * Math.PI * 2;
            const phiS = Math.acos(2 * Math.random() - 1);
            pos[i3] = rScatter * Math.sin(phiS) * Math.cos(thetaS);
            pos[i3 + 1] = rScatter * Math.sin(phiS) * Math.sin(thetaS);
            pos[i3 + 2] = rScatter * Math.cos(phiS);

            // TREE POS: Cone Volume (Thick Shell)
            // Height
            const normalizedY = Math.random();
            const y = (normalizedY * TREE_HEIGHT) - (TREE_HEIGHT / 2);
            
            // Radius calculation with thickness
            const maxRadiusAtY = TREE_RADIUS * (1 - normalizedY);
            // Volume sampling: r = R * sqrt(random)
            // To keep it looking like a "shell" but thick, we map random to 0.5-1.0 range mostly
            const thickness = 0.4 + (Math.random() * 0.6); 
            const rTree = maxRadiusAtY * thickness;

            const thetaT = Math.random() * Math.PI * 2;
            
            treePos[i3] = rTree * Math.cos(thetaT);
            treePos[i3 + 1] = y;
            treePos[i3 + 2] = rTree * Math.sin(thetaT);

            // Attributes
            rands[i] = Math.random();
            s[i] = 0.5 + Math.random() * 1.5; // Base size
          }

          return { positions: pos, treePositions: treePos, randoms: rands, sizes: s };
        }, []);

        useFrame((stateThree, delta) => {
          if (!shaderRef.current) return;
          
          // Update Time
          shaderRef.current.uniforms.uTime.value = stateThree.clock.elapsedTime;

          // Smoothly interpolate Morph Factor
          const targetMorph = state === TreeMorphState.TREE_SHAPE ? 1 : 0;
          shaderRef.current.uniforms.uMorph.value = THREE.MathUtils.damp(
            shaderRef.current.uniforms.uMorph.value,
            targetMorph,
            TRANSITION_SPEED,
            delta
          );
        });

        return (
          <points>
            <bufferGeometry>
              <bufferAttribute
                attach="attributes-position"
                count={FOLIAGE_COUNT}
                array={positions}
                itemSize={3}
              />
              <bufferAttribute
                attach="attributes-aTreePos"
                count={FOLIAGE_COUNT}
                array={treePositions}
                itemSize={3}
              />
              <bufferAttribute
                attach="attributes-aRandom"
                count={FOLIAGE_COUNT}
                array={randoms}
                itemSize={1}
              />
              <bufferAttribute
                attach="attributes-aSize"
                count={FOLIAGE_COUNT}
                array={sizes}
                itemSize={1}
              />
            </bufferGeometry>
            <shaderMaterial
              ref={shaderRef}
              args={[FoliageShaderMaterial]}
              transparent
              depthWrite={false}
              blending={THREE.AdditiveBlending}
            />
          </points>
        );
      };

      // ----------------------------------------------------------------------
      // COMPONENT: Ornaments
      // ----------------------------------------------------------------------

      const tempObject = new THREE.Object3D();

      const Ornaments = ({ state }) => {
        const giftsRef = useRef(null);
        const baublesRef = useRef(null);

        // Generate Data
        const { gifts, baubles } = useMemo(() => {
          const _gifts = [];
          const _baubles = [];

          for (let i = 0; i < ORNAMENT_COUNT; i++) {
            const isGift = Math.random() > 0.7; // 30% gifts, 70% baubles
            
            // Tree Position (Surface biased)
            // Cap height at 0.94 to leave space for TopStar (Tree top is 1.0)
            const normalizedY = Math.random() * 0.94;
            const y = (normalizedY * TREE_HEIGHT) - (TREE_HEIGHT / 2);
            // Ornaments sit on the outer edge
            const rBase = TREE_RADIUS * (1 - normalizedY);
            const r = rBase * (0.85 + Math.random() * 0.3); // Slightly in or out
            const theta = Math.random() * Math.PI * 2;
            
            const treePos = new THREE.Vector3(r * Math.cos(theta), y, r * Math.sin(theta));

            // Scatter Position
            const rScatter = 15 + Math.random() * 25;
            const thetaS = Math.random() * Math.PI * 2;
            const phiS = Math.acos(2 * Math.random() - 1);
            const scatterPos = new THREE.Vector3(
              rScatter * Math.sin(phiS) * Math.cos(thetaS),
              rScatter * Math.sin(phiS) * Math.sin(thetaS),
              rScatter * Math.cos(phiS)
            );

            // Random spin for scattered state
            const spinVector = new THREE.Vector3(
              (Math.random() - 0.5) * 1.5,
              (Math.random() - 0.5) * 1.5,
              (Math.random() - 0.5) * 1.5
            );

            const data = {
              id: i,
              type: isGift ? 'gift' : 'bauble',
              // Gifts are Gold or Dark Green, Baubles are Gold or Warm White
              color: isGift 
                ? (Math.random() > 0.5 ? COLOR_GOLD : new THREE.Color('#022b1c')) 
                : (Math.random() > 0.8 ? COLOR_WARM_WHITE : COLOR_GOLD),
              scale: isGift ? 0.6 + Math.random() * 0.4 : 0.3 + Math.random() * 0.3,
              spinVector,
              phase: Math.random() * Math.PI * 2,
              scatterPos,
              treePos
            };

            if (isGift) _gifts.push(data);
            else _baubles.push(data);
          }
          return { gifts: _gifts, baubles: _baubles };
        }, []);

        // Set initial colors
        useLayoutEffect(() => {
          if (giftsRef.current) {
            gifts.forEach((d, i) => {
              giftsRef.current.setColorAt(i, d.color);
            });
            giftsRef.current.instanceColor.needsUpdate = true;
          }
          if (baublesRef.current) {
            baubles.forEach((d, i) => {
              baublesRef.current.setColorAt(i, d.color);
            });
            baublesRef.current.instanceColor.needsUpdate = true;
          }
        }, [gifts, baubles]);

        // Shader Injection Logic for Sparkles
        const onBeforeCompile = useMemo(() => (shader) => {
          shader.uniforms.uTime = { value: 0 };

          // Inject noise function and varying
          shader.fragmentShader = `
            uniform float uTime;
            
            // Fast hash for noise
            float sparkHash(vec3 p) {
              p = fract(p * 0.3183099 + .1);
              p *= 17.0;
              return fract(p.x * p.y * p.z * (p.x + p.y + p.z));
            }

            ${shader.fragmentShader}
          `;

          // Inject sparkle calculation
          shader.fragmentShader = shader.fragmentShader.replace(
            '#include <tonemapping_fragment>',
            `
            #include <tonemapping_fragment>

            // Calculate Sparkle
            // We use view space position for a "glitter" effect that changes as you look around
            // Scale it up for high frequency
            vec3 sparkPos = vViewPosition * 8.0; 
            
            // Add some time-based movement to the noise coordinates
            float h = sparkHash(floor(sparkPos + vec3(0.0, uTime * 0.2, 0.0)));
            
            // Threshold for sparkles (only top 1%)
            float sparkle = step(0.99, h);
            
            // Blink animation
            float blink = sin(uTime * 4.0 + h * 100.0) * 0.5 + 0.5;
            
            // Mix sparkle color (Gold/White)
            vec3 sparkColor = vec3(1.0, 0.9, 0.6); 
            
            // Add to output
            gl_FragColor.rgb += sparkColor * sparkle * blink * 0.6;
            `
          );

          // Save shader reference for updating uniforms
          shader.userData = { ...shader.userData, uniforms: shader.uniforms };
        }, []);

        useFrame((stateThree, delta) => {
          const time = stateThree.clock.elapsedTime;
          const isTree = state === TreeMorphState.TREE_SHAPE;

          // Correct way to update uniforms injected via onBeforeCompile:
          if (giftsRef.current) {
            const mat = giftsRef.current.material;
            if (mat.userData.shader) mat.userData.shader.uniforms.uTime.value = time;
          }
          if (baublesRef.current) {
            const mat = baublesRef.current.material;
            if (mat.userData.shader) mat.userData.shader.uniforms.uTime.value = time;
          }

          // Helper to update a mesh position/rotation
          const updateMesh = (mesh, data) => {
            data.forEach((d, i) => {
              // Target Position Logic
              let tx, ty, tz;
              
              if (isTree) {
                // Tree Mode: Minimal hovering/breathing
                tx = d.treePos.x + Math.sin(time * 1.5 + d.phase) * 0.02;
                ty = d.treePos.y + Math.cos(time * 1.0 + d.phase) * 0.05; // Vertical Bob
                tz = d.treePos.z + Math.sin(time * 1.5 + d.phase + 1) * 0.02;
              } else {
                // Scatter Mode: Wide, organic floating (3D Lissajous-ish)
                tx = d.scatterPos.x + Math.sin(time * 0.3 + d.phase) * 1.5;
                ty = d.scatterPos.y + Math.cos(time * 0.4 + d.phase * 0.5) * 1.5;
                tz = d.scatterPos.z + Math.sin(time * 0.5 + d.phase * 0.8) * 1.5;
              }

              // Current Transform
              mesh.getMatrixAt(i, tempObject.matrix);
              tempObject.matrix.decompose(tempObject.position, tempObject.quaternion, tempObject.scale);

              // Damp Position
              const dampSpeed = d.type === 'gift' ? TRANSITION_SPEED * 0.8 : TRANSITION_SPEED;
              
              tempObject.position.x = THREE.MathUtils.damp(tempObject.position.x, tx, dampSpeed, delta);
              tempObject.position.y = THREE.MathUtils.damp(tempObject.position.y, ty, dampSpeed, delta);
              tempObject.position.z = THREE.MathUtils.damp(tempObject.position.z, tz, dampSpeed, delta);

              // Rotation Logic
              if (d.type === 'gift') {
                  const targetRotX = isTree 
                      ? Math.sin(time * 1.5 + d.phase) * 0.08 
                      : time * d.spinVector.x;

                  const targetRotY = isTree 
                      ? d.phase + Math.sin(time * 1 + d.phase) * 0.1 
                      : time * d.spinVector.y;

                  const targetRotZ = isTree 
                      ? Math.cos(time * 1.2 + d.phase) * 0.08 
                      : time * d.spinVector.z;

                  tempObject.rotation.x = THREE.MathUtils.damp(tempObject.rotation.x, targetRotX, dampSpeed, delta);
                  tempObject.rotation.y = THREE.MathUtils.damp(tempObject.rotation.y, targetRotY, dampSpeed, delta);
                  tempObject.rotation.z = THREE.MathUtils.damp(tempObject.rotation.z, targetRotZ, dampSpeed, delta);

              } else {
                  tempObject.rotation.x = THREE.MathUtils.damp(tempObject.rotation.x, isTree ? 0 : time * d.spinVector.x, dampSpeed, delta);
                  tempObject.rotation.y += delta * 0.5; 
                  tempObject.rotation.z = THREE.MathUtils.damp(tempObject.rotation.z, isTree ? 0 : time * d.spinVector.z, dampSpeed, delta);
              }

              // Scale
              tempObject.scale.setScalar(d.scale);

              tempObject.updateMatrix();
              mesh.setMatrixAt(i, tempObject.matrix);
            });
            mesh.instanceMatrix.needsUpdate = true;
          };

          if (giftsRef.current) updateMesh(giftsRef.current, gifts);
          if (baublesRef.current) updateMesh(baublesRef.current, baubles);
        });

        return (
          <group>
            {/* GIFTS: Boxes */}
            <instancedMesh ref={giftsRef} args={[undefined, undefined, gifts.length]}>
              <boxGeometry args={[1, 1, 1]} /> 
              <meshStandardMaterial 
                  metalness={0.6} 
                  roughness={0.2} 
                  emissive={new THREE.Color('#000000')}
                  onBeforeCompile={(shader) => {
                    onBeforeCompile(shader);
                    if (giftsRef.current) {
                      giftsRef.current.material.userData.shader = shader;
                    }
                  }}
              />
            </instancedMesh>

            {/* BAUBLES: Spheres */}
            <instancedMesh ref={baublesRef} args={[undefined, undefined, baubles.length]}>
              <sphereGeometry args={[1, 16, 16]} /> 
              <meshStandardMaterial 
                  metalness={1} 
                  roughness={0.05} 
                  emissive={COLOR_GOLD}
                  emissiveIntensity={0.2}
                  toneMapped={false}
                  onBeforeCompile={(shader) => {
                    onBeforeCompile(shader);
                    if (baublesRef.current) {
                      baublesRef.current.material.userData.shader = shader;
                    }
                  }}
              />
            </instancedMesh>
          </group>
        );
      };

      // ----------------------------------------------------------------------
      // COMPONENT: TopStar
      // ----------------------------------------------------------------------

      const TopStar = ({ state }) => {
        const meshRef = useRef(null);
        const materialRef = useRef(null);

        // Procedural Star Shape
        const starShape = useMemo(() => {
          const shape = new THREE.Shape();
          const outerRadius = 1.2;
          const innerRadius = 0.5;
          const points = 5;

          for (let i = 0; i < points * 2; i++) {
            const angle = (i * Math.PI) / points;
            const radius = i % 2 === 0 ? outerRadius : innerRadius;
            const x = Math.cos(angle) * radius;
            const y = Math.sin(angle) * radius;
            if (i === 0) shape.moveTo(x, y);
            else shape.lineTo(x, y);
          }
          shape.closePath();
          return shape;
        }, []);

        const extrudeSettings = useMemo(() => ({
          depth: 0.4,
          bevelEnabled: true,
          bevelThickness: 0.1,
          bevelSize: 0.1,
          bevelSegments: 5
        }), []);

        useFrame((stateThree, delta) => {
          if (!meshRef.current) return;

          // Target position logic
          // Raised from 7.5 to 9.2 to sit clearly on top of the tree tip (which is at y=8)
          const targetY = state === TreeMorphState.TREE_SHAPE ? 9.2 : 16; 
          const targetScale = state === TreeMorphState.TREE_SHAPE ? 1.2 : 0.01; // Slightly larger scale

          // Smooth movement
          meshRef.current.position.y = THREE.MathUtils.damp(
            meshRef.current.position.y,
            targetY,
            TRANSITION_SPEED,
            delta
          );

          // Scale animation (pop out when forming tree)
          const currentScale = meshRef.current.scale.x;
          const nextScale = THREE.MathUtils.damp(currentScale, targetScale, TRANSITION_SPEED, delta);
          meshRef.current.scale.setScalar(nextScale);
          
          // Rotate slowly
          meshRef.current.rotation.y += delta * 0.5;
          meshRef.current.rotation.z = Math.sin(stateThree.clock.elapsedTime * 0.5) * 0.1;
        });

        return (
          <Float speed={2} rotationIntensity={0.2} floatIntensity={0.5}>
            <Extrude
              ref={meshRef}
              args={[starShape, extrudeSettings]}
              position={[0, 16, 0]} // Start high
              rotation={[0, 0, Math.PI / 10]} // Initial rotation to stand straight
              renderOrder={999} 
            >
              <meshStandardMaterial
                ref={materialRef}
                color={COLOR_GOLD}
                emissive={COLOR_GOLD}
                emissiveIntensity={2.5} // Increased bloom intensity
                metalness={1}
                roughness={0.1}
                toneMapped={false}
              />
            </Extrude>
          </Float>
        );
      };

      // ----------------------------------------------------------------------
      // COMPONENT: ArixTree
      // ----------------------------------------------------------------------

      const ArixTree = ({ state }) => {
        return (
          <group>
              {/* Layer 1: The Needle Foliage (Points) */}
              <Foliage state={state} />
              
              {/* Layer 2: The Decorations (Instanced Meshes) */}
              <Ornaments state={state} />
          </group>
        );
      };

      // ----------------------------------------------------------------------
      // COMPONENT: Scene
      // ----------------------------------------------------------------------

      const Scene = ({ treeState }) => {
        return (
          <Canvas 
            dpr={[1, 2]} 
            gl={{ antialias: false, toneMappingExposure: 1.5 }} // Disable default AA for PostProcessing performance, boost exposure
          >
            <PerspectiveCamera makeDefault position={[0, 0, 25]} fov={45} />
            
            {/* Controls */}
            <OrbitControls 
              enablePan={false} 
              minPolarAngle={Math.PI / 4} 
              maxPolarAngle={Math.PI / 2}
              minDistance={10}
              maxDistance={40}
              autoRotate={treeState === TreeMorphState.TREE_SHAPE}
              autoRotateSpeed={0.5}
            />

            {/* Lighting System */}
            <ambientLight intensity={0.2} color={COLOR_EMERALD} />
            <directionalLight 
              position={[10, 10, 5]} 
              intensity={2} 
              color="#ffecd2" // Warm Sun
            />
            <pointLight position={[-10, -5, -5]} intensity={1} color={COLOR_GOLD} />

            {/* Environment Reflections */}
            <Environment preset="city" />

            {/* Content */}
            <group position={[0, -2, 0]}>
              <ArixTree state={treeState} />
              <TopStar state={treeState} />
            </group>

            {/* Post Processing */}
            <EffectComposer disableNormalPass>
              {/* Intense Bloom for the Gold and Lights */}
              <Bloom 
                luminanceThreshold={0.8} // Only very bright things glow
                mipmapBlur 
                intensity={1.5} 
                radius={0.6}
              />
              <Vignette eskil={false} offset={0.1} darkness={0.6} />
            </EffectComposer>
            
            {/* Background to make it seamless */}
            <color attach="background" args={['#010a05']} />
          </Canvas>
        );
      };

      // ----------------------------------------------------------------------
      // APP
      // ----------------------------------------------------------------------

      // Icons
      const IconTree = () => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
          <path strokeLinecap="round" strokeLinejoin="round" d="M12 21v-8.25M15.75 21v-8.25M8.25 21v-8.25M3 9l9-6 9 6m-1.5 12V10.332A48.36 48.36 0 0012 9.75c-2.551 0-5.056.2-7.5.582V21M3 21h18M12 6.75h.008v.008H12V6.75z" />
        </svg>
      );

      const IconScatter = () => (
        <svg xmlns="http://www.w3.org/2000/svg" fill="none" viewBox="0 0 24 24" strokeWidth={1.5} stroke="currentColor" className="w-6 h-6">
          <path strokeLinecap="round" strokeLinejoin="round" d="M21 7.5l-2.25-1.313M21 7.5v2.25m0-2.25l-2.25 1.313M3 7.5l2.25-1.313M3 7.5l2.25 1.313M3 7.5v2.25m9 3l2.25-1.313M12 12.75l-2.25-1.313M12 12.75V15m0 6.75l2.25-1.313M12 21.75V19.5m0 2.25l-2.25-1.313m0-16.875L12 2.25l2.25 1.313M21 14.25v2.25l-2.25 1.313m0-16.875L18 2.25M5.25 2.25v2.25L3 5.625M2.25 6.75l2.25-1.313M5.25 2.25L7.5 3.563M2.25 6.75L4.5 5.625m2.25 13.5h3.75m-3.75 0V21m3.75-1.875V21m-9-4.5h3.75m-3.75 0V21m3.75-1.875V21" />
        </svg>
      );

      const App = () => {
        const [treeState, setTreeState] = useState(TreeMorphState.SCATTERED);

        const toggleState = () => {
          setTreeState((prev) => 
            prev === TreeMorphState.TREE_SHAPE 
              ? TreeMorphState.SCATTERED 
              : TreeMorphState.TREE_SHAPE
          );
        };

        // Remove Loader
        useLayoutEffect(() => {
          const loader = document.getElementById('loader');
          if(loader) loader.style.opacity = '0';
        }, []);

        return (
          <div className="relative w-full h-full font-sans">
            {/* 3D Scene */}
            <div className="absolute inset-0 z-0">
              <Scene treeState={treeState} />
            </div>

            {/* UI Overlay */}
            <div className="absolute inset-0 z-10 pointer-events-none flex flex-col justify-between p-8">
              
              {/* Header */}
              <header className="flex justify-between items-start">
                <div>
                  <h1 className="text-white text-3xl font-light tracking-widest uppercase" style={{ fontFamily: 'Times New Roman, serif' }}>
                    Arix <span className="text-yellow-400 font-bold">Signature</span>
                  </h1>
                  <p className="text-emerald-200 text-sm tracking-widest mt-1 opacity-80">Interactive Holiday Experience</p>
                </div>
              </header>

              {/* Footer Controls */}
              <div className="flex flex-col items-center pointer-events-auto gap-6 mb-8">
                 <button
                  onClick={toggleState}
                  className={`
                    group relative flex items-center justify-center gap-3 px-8 py-4 
                    rounded-full backdrop-blur-md border transition-all duration-500
                    \${treeState === TreeMorphState.TREE_SHAPE 
                      ? 'bg-emerald-900/60 border-yellow-500/50 text-yellow-100 shadow-[0_0_30px_rgba(255,215,0,0.2)]' 
                      : 'bg-white/10 border-white/20 text-white hover:bg-white/20'}
                  `}
                >
                   <span className="relative z-10 flex items-center gap-2 font-medium tracking-wider uppercase text-sm">
                      {treeState === TreeMorphState.TREE_SHAPE ? <IconScatter /> : <IconTree />}
                      {treeState === TreeMorphState.TREE_SHAPE ? 'Release Magic' : 'Gather Spirit'}
                   </span>
                   
                   {/* Glow Effect */}
                   <div className={`absolute inset-0 rounded-full transition-opacity duration-500 \${treeState === TreeMorphState.TREE_SHAPE ? 'opacity-100' : 'opacity-0'}`}>
                      <div className="absolute inset-0 bg-yellow-400/10 blur-xl rounded-full"></div>
                   </div>
                </button>

                <div className="text-white/40 text-xs tracking-widest uppercase">
                  Designed for Chrome & Safari 
                </div>
              </div>
            </div>
          </div>
        );
      };

      // ----------------------------------------------------------------------
      // MOUNT
      // ----------------------------------------------------------------------
      
      const rootElement = document.getElementById('root');
      const root = ReactDOM.createRoot(rootElement);
      root.render(
        <React.StrictMode>
          <App />
        </React.StrictMode>
      );
    </script>
  <script type="module" src="/index.tsx"></script>
</body>
</html>